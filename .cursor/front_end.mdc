---
alwaysApply: false
---
1. Загальна характеристика фронт-енд підсистеми

Клієнтська частина системи управління інтернет-магазином реалізована у вигляді веб-додатку на основі бібліотеки React з використанням мови JavaScript. Фронт-енд відповідає за відображення інтерфейсу користувача, обробку взаємодії з ним, формування та відправку HTTP-запитів до серверної частини (REST API), а також за відображення отриманих від сервера даних.

Основні завдання фронт-енд підсистеми:

надання зручного інтерфейсу для перегляду каталогу товарів, роботи з кошиком та оформлення замовлення;

забезпечення можливості реєстрації, авторизації та роботи з особистим кабінетом клієнта;

реалізація адміністративної панелі для керування товарами, категоріями, замовленнями та промокодами;

відображення звітів (продажі по категоріях, доходи за період, найпопулярніші товари).

Взаємодія з сервером здійснюється за REST-підходом: фронт-енд надсилає HTTP-запити до відповідних ендпоінтів API та отримує відповіді у форматі JSON.

2. Вибір технологій та інструментів

Для реалізації клієнтської частини обрано такі технології:

React – бібліотека для побудови інтерфейсу користувача на основі компонентного підходу.

JavaScript (ES6+) – основна мова програмування фронт-енд логіки.

React Router – бібліотека для організації клієнтської маршрутизації (SPA, Single Page Application).

CSS / SCSS (або інший підхід до стилізації) – для оформлення зовнішнього вигляду додатку.

Fetch API / axios – для виконання HTTP-запитів до бек-енду.

Використання React дозволяє будувати застосунок як набір ізольованих компонентів, які повторно використовуються та легко комбінуються. Це підвищує модульність, спрощує тестування та супровід коду.

3. Архітектура фронт-енд додатку
3.1. Загальна схема

Фронт-енд реалізовано у вигляді односторінкового додатку (SPA). Умовно можна виділити такі рівні:

Рівень маршрутизації (Routing Layer)
Відповідає за відображення потрібної сторінки в залежності від URL. Реалізований за допомогою React Router через набір маршрутів:

публічні маршрути (каталог, сторінка товару, логін, реєстрація);

маршрути, доступні тільки авторизованому клієнту (кошик, оформлення замовлення, профіль, історія замовлень);

маршрути адміністраторської частини (адмін-панель, управління товарами, замовленнями, промокодами, звітами).

Рівень представлення (View Layer / Components)
Містить React-компоненти, відповідальні за відображення інтерфейсу: сторінки, форми, таблиці, картки товарів тощо. Компоненти поділяються на:

сторінкові компоненти (page components): HomePage, ProductListPage, ProductDetailsPage, CartPage, CheckoutPage, ProfilePage, AdminProductsPage, AdminOrdersPage, AdminReportsPage тощо;

презентаційні компоненти (presentational): ProductCard, CartItem, OrderRow, AdminSidebar, Header, Footer тощо.

Рівень логіки та доступу до даних (Client Services / API Layer)
Реалізовано у вигляді окремих модулів/функцій для взаємодії з REST API, наприклад:

api/authApi.js – авторизація, реєстрація, отримання поточного користувача;

api/productsApi.js – робота з товарами та категоріями;

api/cartApi.js – операції з кошиком;

api/ordersApi.js – створення та отримання замовлень;

api/adminApi.js – адмінські звіти, промокоди тощо.

Рівень керування станом (State Management)
В додатку використовується вбудований механізм стану React (хуки useState, useReducer) та React Context для зберігання глобального стану:

контекст авторизації (AuthContext) – інформація про поточного користувача, роль, токен доступу;

контекст кошика (CartContext) – поточний склад кошика, сума замовлення, тощо.

Таким чином, компонентна архітектура React поєднується з чітким розділенням відповідальностей між рівнями відображення, логіки та доступу до даних.

4. Структура фронт-енд проєкту

Типова структура каталогу src для фронт-енд частини може виглядати так:

src/
  index.js
  App.js
  router/
    AppRouter.js
    PrivateRoute.js
    AdminRoute.js
  pages/
    HomePage.js
    ProductListPage.js
    ProductDetailsPage.js
    CartPage.js
    CheckoutPage.js
    LoginPage.js
    RegisterPage.js
    ProfilePage.js
    AdminDashboardPage.js
    AdminProductsPage.js
    AdminOrdersPage.js
    AdminPromocodesPage.js
    AdminReportsPage.js
  components/
    layout/
      Header.js
      Footer.js
      AdminSidebar.js
    catalog/
      ProductCard.js
      ProductFilter.js
    cart/
      CartItem.js
      CartSummary.js
    orders/
      OrderList.js
      OrderDetails.js
    common/
      Button.js
      Input.js
      Loader.js
      ErrorMessage.js
  api/
    authApi.js
    productsApi.js
    cartApi.js
    ordersApi.js
    adminApi.js
  context/
    AuthContext.js
    CartContext.js
  hooks/
    useAuth.js
    useCart.js
  styles/
    main.css


Кожна папка має чітко визначену роль:

pages – цілі сторінки, що відповідають маршрутам;

components – багаторазові компоненти інтерфейсу;

api – обгортки над HTTP-запитами до бек-енду;

context – глобальний стан;

hooks – користувацькі хуки для повторного використання логіки.

5. Опис основних сторінок та інтерфейсу
5.1. Користувацька частина

Головна сторінка / каталог товарів
Відображає список товарів у вигляді карток (ProductCard) з фото, назвою, ціною та кнопкою “Додати в кошик”. Передбачено фільтрацію за категоріями та пошук по назві/опису.

Сторінка товару
Детальний перегляд одиниці товару: розширений опис, зображення, ціна, статус наявності та форма для вибору кількості. Є кнопка “Додати в кошик”.

Сторінки реєстрації та авторизації
Форми введення email та пароля з базовою валідацією. Після успішної авторизації інформація про користувача зберігається в AuthContext, а токен – у localStorage.

Кошик
Виводиться перелік вибраних товарів (компоненти CartItem), можливість змінювати кількість або видаляти позиції. Підраховується проміжна сума, можна ввести промокод.

Оформлення замовлення (checkout)
Форма для введення контактних даних, адреси, вибору способу доставки та оплати. Тут же застосовується промокод, відображаються сума замовлення, знижка та фінальна сума.

Профіль користувача та історія замовлень
Виводиться інформація про клієнта (ім’я, email, адреса) та список попередніх замовлень з датою, сумою та статусом.

5.2. Адміністративна частина

Адмін Dashboard
Стислий огляд: кількість замовлень, доходи за період, топ-товари.

Управління товарами
Таблиця із товарами (назва, категорія, ціна, кількість на складі) та формою для створення/редагування товару.

Управління категоріями
Список доступних категорій та форми для їх редагування.

Управління замовленнями
Таблиця із замовленнями, детальний перегляд замовлення (склад, сума, клієнт, статус), можливість змінити статус.

Управління промокодами
Список промокодів та форми для їх створення та редагування.

Звіти
Відображення даних, отриманих з бек-енду: продажі по категоріях, доходи за період, список найпопулярніших товарів.

6. Взаємодія з REST API

Вся комунікація між фронт-енд та бек-енд частиною реалізується через HTTP-запити до REST API. Для цього створено окремі модулі у папці api, наприклад:

productsApi.js містить функції getProducts, getProductById, createProduct, updateProduct, deleteProduct;

authApi.js – login, register, getCurrentUser;

cartApi.js – getCart, addToCart, updateCartItem, removeCartItem;

ordersApi.js – createOrder, getUserOrders;

adminApi.js – функції для отримання звітів, управління промокодами тощо.

Компоненти та контексти не працюють з fetch безпосередньо, а використовують ці функції, що підвищує розділення відповідальностей та спрощує заміну/рефакторинг API-логіки.

7. Керування станом: авторизація та кошик
7.1. AuthContext

Для зберігання інформації про поточного користувача використовується AuthContext. Він містить:

дані користувача (id, email, роль тощо);

токен доступу;

методи login, logout, register, checkAuth.

Компоненти, яким потрібні дані про користувача (наприклад, Header, ProfilePage, Admin* сторінки), отримують їх через хук useAuth.

7.2. CartContext

CartContext відповідає за стан кошика:

список товарів у кошику;

загальну суму замовлення;

методи addItem, removeItem, updateQuantity, clearCart.

Таким чином, стан кошика доступний усім компонентам, що його потребують (сторінка кошика, кнопка “Кошик” у шапці сайту, сторінка оформлення замовлення).

8. Валідація, обробка помилок та UX

На фронт-енді реалізовано:

клієнтську валідацію форм (логін, реєстрація, checkout) – перевірка обов’язкових полів, форматів email, мінімальної довжини пароля тощо;

обробку помилок API – при невдалому HTTP-запиті користувач отримує повідомлення про помилку (наприклад, у вигляді компоненту ErrorMessage або сповіщень);

стани завантаження (loading) – під час виконання запитів відображаються індикатори завантаження (компонент Loader).

Також інтерфейс реалізовано адаптивно, щоб застосунок коректно працював як на десктопних пристроях, так і на екранах меншого розміру.

9. Використані патерни та принципи на рівні фронт-енду
9.1. Чи патерни тільки для бек-енду?

Класичні GoF-патерни (Strategy, Factory Method, Singleton, Facade, Observer, Template Method), на які робиться акцент у завданні, в основному реалізуються на рівні бізнес-логіки та доменної моделі, тобто переважно на бек-енді (у сервісах, репозиторіях, модулях оплати, знижок, звітів тощо).

Фронт-енд частина, однак, теж використовує підходи та шаблони, але вони більше стосуються:

архітектури інтерфейсу;

організації компонентів;

керування станом.

У курсовій роботі можна зазначити, що:

основні GoF-патерни (Strategy, Factory, Singleton, Facade, Observer, Template Method) реалізовано на бек-енді;

фронт-енд застосовує архітектурні патерни та best practices React-додатків.

9.2. Патерни й підходи на фронт-енді

На рівні React-фронт-енду використовуються такі ідеї:

Компонентно-орієнтована архітектура
Увесь інтерфейс розбитий на дрібні компоненти, які відповідають принципу Single Responsibility (SRP): кожен компонент вирішує одну локальну задачу (відображає картку товару, рядок таблиці, форму тощо). Це узгоджується з принципами SOLID.

Поділ на контейнерні та презентаційні компоненти

Контейнерні компоненти (сторінки, layout-и) містять логіку завантаження даних, викликають API та керують станом.

Презентаційні компоненти відповідають лише за відображення (отримують дані через props і не знають про джерело цих даних).

Це зменшує зв’язаність (low coupling) і підвищує зрозумілість та повторне використання коду.

Використання контекстів (Context) як спільного стану
Підхід схожий на Observer: компоненти “підписуються” на зміни контексту (авторизація, кошик) і автоматично оновлюються при зміні стану. Формально це реалізація механізму підписки/сповіщення у рамках React.

Фасад для роботи з API
Модулі api/*.js можна розглядати як спрощений Facade: вони приховують деталі формування HTTP-запитів від компонентів. Компонентам достатньо викликати productsApi.getProducts(), не знаючи, на який саме URL і з якими заголовками виконується запит.

GRASP-принципи на фронт-енді

Controller – роль контролерів виконують сторінкові компоненти та маршрутизатор (React Router), які приймають події від користувача й делегують їх сервісам/контекстам.

High Cohesion – логічно пов’язані частини інтерфейсу згруповані в компоненти/модулі.

Low Coupling – компоненти отримують дані через props або контексти, що зменшує залежності.

Отже, хоча основна реалізація GoF-патернів знаходиться на бек-енді, фронт-енд частина теж спирається на шаблони та принципи проектування, характерні для React-додатків та клієнтських SPA.

10. Висновок по фронт-енд частині

Фронт-енд частина системи управління інтернет-магазином реалізована як односторінковий React-додаток з чітким розподілом відповідальностей між рівнями інтерфейсу, логіки та доступу до даних. Застосовано компонентний підхід, клієнтську маршрутизацію, глобальний стан (контексти), а також розділення на користувацьку та адміністративну частини.

Фронт-енд використовує результати серверної реалізації шаблонів проєктування (GoF, GRASP, SOLID), надаючи користувачеві зручний та інтуїтивний інтерфейс для роботи з товарами, кошиком, замовленнями та звітністю.