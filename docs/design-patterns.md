# Патерни Проектування в E-Commerce Системі EL3CTRO

## 1. Facade Pattern (Структурний патерн)

### Реалізація

**Файли:**
- `backend/src/patterns/checkout/CheckoutFacade.js` - основний клас патерну
- `backend/src/services/orderService.js` - використання патерну (рядки 4, 8-12, 37)

**Деталі використання:**
- У `orderService.js` створюється екземпляр `CheckoutFacade` з залежностями (cartService, paymentGateway, shippingProvider)
- Метод `checkoutFacade.checkout()` викликається в `orderService.checkout()` для спрощення процесу оформлення замовлення

### Опис

**Призначення:** Facade Pattern надає спрощений, уніфікований інтерфейс до складної підсистеми оформлення замовлення.

**Навіщо використовується:**
1. **Спрощення складних операцій:** Процес checkout включає багато кроків: отримання кошика, валідацію промокодів, розрахунок доставки, створення замовлення, обробку платежів та відправки. Facade об'єднує всі ці операції в один простий метод `checkout()`.

2. **Приховування складності:** Приховує деталі взаємодії з множиною сервісів та компонентів:
   - `cartService` - робота з кошиком
   - `promotionService` - валідація та розрахунок промокодів
   - `OrderBuilder` - побудова об'єкта замовлення
   - `ShippingStrategy` - розрахунок вартості доставки
   - `paymentGateway` - обробка платежів
   - `shippingProvider` - створення відправки

3. **Зменшення зв'язаності:** Клієнтський код (`orderService.checkout()`) не потребує знати про внутрішню структуру та послідовність викликів різних сервісів. Зміни в підсистемі не впливають на клієнтський код.

4. **Покращення читабельності:** Замість довгого послідовного коду з багатьма залежностями в одному місці, весь процес інкапсульований в одному методі з чіткою назвою.

---

## 2. Builder Pattern (Породжуючий патерн)

### Реалізація

**Файли:**
- `backend/src/patterns/order/OrderBuilder.js` - основний клас патерну
- `backend/src/patterns/checkout/CheckoutFacade.js` - використання патерну (рядки 20, 104-110)

**Деталі використання:**
- У `CheckoutFacade.checkout()` створюється екземпляр `OrderBuilder`
- Використовуються методи для покрокової побудови замовлення: `withCart()`, `withCustomer()`, `withPromotion()`, `withShipping()`, `withTax()`, `finalizeTotals()`
- Метод `build()` повертає готовий об'єкт замовлення (orderDraft)

### Опис

**Призначення:** Builder Pattern дозволяє покроково будувати складні об'єкти замовлень, використовуючи той самий процес побудови для отримання різних представлень.

**Навіщо використовується:**
1. **Покрокова побудова складних об'єктів:** Об'єкт замовлення має багато параметрів (subtotal, discount, shipping, tax, total, items, promotionId, userId тощо). Builder дозволяє будувати його покроково, додаючи компоненти в будь-якому порядку.

2. **Гнучкість конструкції:** Дозволяє комбінувати різні параметри, деякі з яких є опціональними (наприклад, промокод може бути або не бути). Кожен метод додає конкретну частину до замовлення.

3. **Відокремлення процесу створення:** Процес створення замовлення відокремлений від його представлення. Метод `build()` створює фінальний об'єкт тільки коли всі необхідні дані додані.

4. **Перевикористання:** Метод `reset()` дозволяє очистити будівника та використовувати його повторно для створення іншого замовлення.

5. **Валідація під час побудови:** Кожен метод може містити валідацію даних перед додаванням до об'єкта, що забезпечує коректність даних.

6. **Покращення читабельності:** Замість передачі багатьох параметрів у конструктор, код стає більш читабельним та зрозумілим через ланцюжок методів з описовими назвами.

---

## 3. Strategy Pattern - Shipping (Поведінковий патерн)

### Реалізація

**Файли:**
- `backend/src/patterns/shipping/ShippingStrategy.js` - основний файл з усіма стратегіями
- `backend/src/patterns/checkout/CheckoutFacade.js` - використання патерну (рядки 21, 98, 99-102)

**Структура:**
- `BaseShippingStrategy` - базовий клас стратегії
- `ExpressShippingStrategy` - стратегія швидкої доставки
- `EconomyShippingStrategy` - стратегія економ доставки
- `NovaPoshtaShippingStrategy` - стратегія доставки Новою Поштою
- `PickupShippingStrategy` - стратегія самовивозу (безкоштовно)
- `getShippingStrategy(method)` - функція для отримання потрібної стратегії

**Деталі використання:**
- У `CheckoutFacade.checkout()` викликається `getShippingStrategy(shippingMethod)` для отримання потрібної стратегії
- Метод `calculate()` стратегії викликається для розрахунку вартості доставки

### Опис

**Призначення:** Strategy Pattern визначає сімейство алгоритмів розрахунку вартості доставки, інкапсулює кожен з них і робить їх взаємозамінними.

**Навіщо використовується:**
1. **Динамічний вибір алгоритму:** Дозволяє вибирати алгоритм розрахунку вартості доставки під час виконання програми на основі обраного користувачем методу доставки (express, economy, nova-poshta, pickup).

2. **Інкапсуляція алгоритмів:** Кожен алгоритм розрахунку інкапсульований у власному класі стратегії:
   - `ExpressShippingStrategy` - швидка доставка (макс 120 грн або 4% від суми)
   - `EconomyShippingStrategy` - економ доставка (фіксовано 80 грн)
   - `NovaPoshtaShippingStrategy` - доставка Новою Поштою (макс 110 грн або 3% від суми)
   - `PickupShippingStrategy` - самовивіз (0 грн)

3. **Легке розширення:** Додавання нового методу доставки не вимагає зміни існуючого коду - достатньо створити новий клас стратегії та додати його в функцію `getShippingStrategy()`.

4. **Усунення умовних операторів:** Замість великого switch/case або множини if/else в одному місці, кожна стратегія має власну логіку, що покращує читабельність та підтримуваність коду.

5. **Відокремлення бізнес-логіки:** Логіка розрахунку вартості доставки відокремлена від основної бізнес-логіки оформлення замовлення, що сприяє принципу єдиної відповідальності (Single Responsibility Principle).

6. **Тестованість:** Кожну стратегію можна тестувати незалежно, що спрощує написання unit-тестів.

---

## 4. Strategy Pattern + Factory Method - Promotions (Поведінковий + Породжуючий патерни)

### Реалізація

**Файли:**
- `backend/src/patterns/promotions/PromotionFactory.js` - основний файл з усіма стратегіями та фабрикою
- `backend/src/services/promotionService.js` - використання патерну (рядки 2, 36-37)

**Структура:**
- `BasePromotionStrategy` - базовий клас стратегії
- `PercentagePromotionStrategy` - стратегія відсоткової знижки
- `FixedPromotionStrategy` - стратегія фіксованої знижки
- `ShippingPromotionStrategy` - стратегія знижки на доставку
- `createPromotionStrategy(promotion)` - фабричний метод для створення стратегії

**Деталі використання:**
- У `promotionService.calculateDiscount()` викликається `createPromotionStrategy(promotion)` для отримання потрібної стратегії
- Метод `calculate(cart)` стратегії викликається для розрахунку розміру знижки

### Опис

**Призначення:** Комбінація Strategy та Factory Method патернів для розрахунку знижок на основі типу промокоду.

**Навіщо використовується:**

#### Strategy Pattern:
1. **Різні алгоритми розрахунку знижок:** Кожен тип промокоду має власний алгоритм розрахунку:
   - `PercentagePromotionStrategy` - відсоткова знижка від суми замовлення (наприклад, 10% від subtotal)
   - `FixedPromotionStrategy` - фіксована сума знижки (наприклад, 500 грн)
   - `ShippingPromotionStrategy` - знижка на доставку (зменшує вартість доставки)

2. **Взаємозамінність алгоритмів:** Стратегії можна змінювати під час виконання програми без зміни коду, який їх використовує.

3. **Інкапсуляція логіки:** Логіка розрахунку різних типів знижок інкапсульована в окремих класах, що покращує організацію коду.

#### Factory Method Pattern:
1. **Динамічне створення об'єктів:** Фабричний метод `createPromotionStrategy()` створює потрібний клас стратегії на основі типу промокоду (PERCENTAGE, FIXED, SHIPPING), не вказуючи точний клас в коді.

2. **Приховування логіки створення:** Логіка вибору правильного класу стратегії прихована від клієнтського коду (`promotionService`). Клієнтський код просто викликає фабричний метод з об'єктом промокоду.

3. **Легке додавання нових типів:** Для додавання нового типу промокоду достатньо:
   - Створити новий клас стратегії, що наслідує `BasePromotionStrategy`
   - Додати case в switch `createPromotionStrategy()`
   - Клієнтський код залишається незмінним

4. **Розширюваність:** Система легко розширюється без модифікації існуючого коду, що відповідає принципу Open/Closed (відкрито для розширення, закрито для модифікації).

5. **Централізоване керування створенням:** Вся логіка створення стратегій зосереджена в одному місці (фабричний метод), що спрощує підтримку та зміни.

**Переваги комбінації:**
- Strategy Pattern забезпечує гнучкість у виборі алгоритму розрахунку
- Factory Method Pattern забезпечує правильне створення потрібної стратегії
- Разом вони створюють потужну та гнучку систему для роботи з різними типами промокодів

---

## Загальні переваги використання патернів

1. **Підтримуваність:** Код стає більш структурованим та легшим для розуміння та зміни
2. **Розширюваність:** Легко додавати нові функції без зміни існуючого коду
3. **Тестованість:** Кожен компонент можна тестувати незалежно
4. **Перевикористання:** Компоненти можна використовувати в різних частинах системи
5. **Відокремлення відповідальностей:** Кожен клас має чітко визначену відповідальність
6. **Зменшення зв'язаності:** Компоненти слабко пов'язані між собою, що спрощує зміни

